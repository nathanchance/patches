From 556b69d74c282761f48d3616344314975bd64c31 Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <nathan@kernel.org>
Date: Mon, 18 Dec 2023 10:52:36 -0700
Subject: [PATCH 02/16] NOTCBL: FROMLIST: v2 of "afs: Fix probe handling,
 server rotation and RO volume callback handling"

Link: https://lore.kernel.org/20231213135003.367397-1-dhowells@redhat.com/
Signed-off-by: Nathan Chancellor <nathan@kernel.org>
---
 fs/afs/callback.c   |  4 ++--
 fs/afs/dir.c        |  2 +-
 fs/afs/inode.c      | 10 +++++-----
 fs/afs/internal.h   |  2 +-
 fs/afs/main.c       |  2 +-
 fs/afs/rotate.c     |  4 ++--
 fs/afs/validation.c |  4 ++--
 7 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/fs/afs/callback.c b/fs/afs/callback.c
index a32050bf8086..99b2c8172021 100644
--- a/fs/afs/callback.c
+++ b/fs/afs/callback.c
@@ -41,7 +41,7 @@ static void afs_volume_init_callback(struct afs_volume *volume)
 
 	list_for_each_entry(vnode, &volume->open_mmaps, cb_mmap_link) {
 		if (vnode->cb_v_check != atomic_read(&volume->cb_v_break)) {
-			vnode->cb_expires_at = AFS_NO_CB_PROMISE;
+			atomic64_set(&vnode->cb_expires_at, AFS_NO_CB_PROMISE);
 			queue_work(system_unbound_wq, &vnode->cb_work);
 		}
 	}
@@ -79,7 +79,7 @@ void __afs_break_callback(struct afs_vnode *vnode, enum afs_cb_break_reason reas
 	_enter("");
 
 	clear_bit(AFS_VNODE_NEW_CONTENT, &vnode->flags);
-	if (xchg(&vnode->cb_expires_at, AFS_NO_CB_PROMISE) != AFS_NO_CB_PROMISE) {
+	if (atomic64_xchg(&vnode->cb_expires_at, AFS_NO_CB_PROMISE) != AFS_NO_CB_PROMISE) {
 		vnode->cb_break++;
 		vnode->cb_v_check = atomic_read(&vnode->volume->cb_v_break);
 		afs_clear_permits(vnode);
diff --git a/fs/afs/dir.c b/fs/afs/dir.c
index 7ea5803c05da..ed5bcb5d8895 100644
--- a/fs/afs/dir.c
+++ b/fs/afs/dir.c
@@ -1376,7 +1376,7 @@ static void afs_dir_remove_subdir(struct dentry *dentry)
 
 		clear_nlink(&vnode->netfs.inode);
 		set_bit(AFS_VNODE_DELETED, &vnode->flags);
-		vnode->cb_expires_at = AFS_NO_CB_PROMISE;
+		atomic64_set(&vnode->cb_expires_at, AFS_NO_CB_PROMISE);
 		clear_bit(AFS_VNODE_DIR_VALID, &vnode->flags);
 	}
 }
diff --git a/fs/afs/inode.c b/fs/afs/inode.c
index 12b90d680fb6..4f04f6f33f46 100644
--- a/fs/afs/inode.c
+++ b/fs/afs/inode.c
@@ -145,10 +145,10 @@ static int afs_inode_init_from_status(struct afs_operation *op,
 	if (!vp->scb.have_cb) {
 		/* it's a symlink we just created (the fileserver
 		 * didn't give us a callback) */
-		vnode->cb_expires_at = AFS_NO_CB_PROMISE;
+		atomic64_set(&vnode->cb_expires_at, AFS_NO_CB_PROMISE);
 	} else {
 		vnode->cb_server = op->server;
-		vnode->cb_expires_at = vp->scb.callback.expires_at;
+		atomic64_set(&vnode->cb_expires_at, vp->scb.callback.expires_at);
 	}
 
 	write_sequnlock(&vnode->cb_lock);
@@ -213,7 +213,7 @@ static void afs_apply_status(struct afs_operation *op,
 
 	if (vp->dv_before + vp->dv_delta != status->data_version) {
 		if (vnode->cb_ro_snapshot == atomic_read(&vnode->volume->cb_ro_snapshot) &&
-		    vnode->cb_expires_at != AFS_NO_CB_PROMISE)
+		    atomic64_read(&vnode->cb_expires_at) != AFS_NO_CB_PROMISE)
 			pr_warn("kAFS: vnode modified {%llx:%llu} %llx->%llx %s (op=%x)\n",
 				vnode->fid.vid, vnode->fid.vnode,
 				(unsigned long long)vp->dv_before + vp->dv_delta,
@@ -269,7 +269,7 @@ static void afs_apply_callback(struct afs_operation *op,
 	if (!afs_cb_is_broken(vp->cb_break_before, vnode)) {
 		if (op->volume->type == AFSVL_RWVOL)
 			vnode->cb_server = op->server;
-		vnode->cb_expires_at = cb->expires_at;
+		atomic64_set(&vnode->cb_expires_at, cb->expires_at);
 	}
 }
 
@@ -586,7 +586,7 @@ int afs_getattr(struct mnt_idmap *idmap, const struct path *path,
 
 	if (vnode->volume &&
 	    !(query_flags & AT_STATX_DONT_SYNC) &&
-	    vnode->cb_expires_at == AFS_NO_CB_PROMISE) {
+	    atomic64_read(&vnode->cb_expires_at) == AFS_NO_CB_PROMISE) {
 		key = afs_request_key(vnode->volume->cell);
 		if (IS_ERR(key))
 			return PTR_ERR(key);
diff --git a/fs/afs/internal.h b/fs/afs/internal.h
index f360726f6082..49efe65c8634 100644
--- a/fs/afs/internal.h
+++ b/fs/afs/internal.h
@@ -740,7 +740,7 @@ struct afs_vnode {
 	unsigned int		cb_v_check;	/* Break check counter on ->volume */
 	seqlock_t		cb_lock;	/* Lock for ->cb_server, ->status, ->cb_*break */
 
-	time64_t		cb_expires_at;	/* time at which callback expires */
+	atomic64_t		cb_expires_at;	/* time at which callback expires */
 #define AFS_NO_CB_PROMISE TIME64_MIN
 };
 
diff --git a/fs/afs/main.c b/fs/afs/main.c
index 33e831e6f712..1b3bd21c168a 100644
--- a/fs/afs/main.c
+++ b/fs/afs/main.c
@@ -156,7 +156,7 @@ static void __net_exit afs_net_exit(struct net *net_ns)
 	afs_close_socket(net);
 	afs_proc_cleanup(net);
 	afs_put_sysnames(net->sysnames);
-	kfree_rcu(net->address_prefs, rcu);
+	kfree_rcu(rcu_access_pointer(net->address_prefs), rcu);
 }
 
 static struct pernet_operations afs_net_ops = {
diff --git a/fs/afs/rotate.c b/fs/afs/rotate.c
index b27782896dd8..700a27bc8c25 100644
--- a/fs/afs/rotate.c
+++ b/fs/afs/rotate.c
@@ -99,7 +99,7 @@ static bool afs_start_fs_iteration(struct afs_operation *op,
 		write_seqlock(&vnode->cb_lock);
 		ASSERTCMP(cb_server, ==, vnode->cb_server);
 		vnode->cb_server = NULL;
-		if (xchg(&vnode->cb_expires_at, AFS_NO_CB_PROMISE) != AFS_NO_CB_PROMISE)
+		if (atomic64_xchg(&vnode->cb_expires_at, AFS_NO_CB_PROMISE) != AFS_NO_CB_PROMISE)
 			vnode->cb_break++;
 		write_sequnlock(&vnode->cb_lock);
 	}
@@ -581,7 +581,7 @@ bool afs_select_fileserver(struct afs_operation *op)
 	if (vnode->cb_server != server) {
 		vnode->cb_server = server;
 		vnode->cb_v_check = atomic_read(&vnode->volume->cb_v_break);
-		vnode->cb_expires_at = AFS_NO_CB_PROMISE;
+		atomic64_set(&vnode->cb_expires_at, AFS_NO_CB_PROMISE);
 	}
 
 retry_server:
diff --git a/fs/afs/validation.c b/fs/afs/validation.c
index 317ed1f29c25..13e9a87ac5c6 100644
--- a/fs/afs/validation.c
+++ b/fs/afs/validation.c
@@ -123,7 +123,7 @@ bool afs_check_validity(const struct afs_vnode *vnode)
 	time64_t deadline = ktime_get_real_seconds() + 10;
 
 	if (atomic_read(&volume->cb_v_check) != atomic_read(&volume->cb_v_break) ||
-	    vnode->cb_expires_at  <= deadline ||
+	    atomic64_read(&vnode->cb_expires_at)  <= deadline ||
 	    volume->cb_expires_at <= deadline ||
 	    vnode->cb_ro_snapshot != atomic_read(&volume->cb_ro_snapshot) ||
 	    vnode->cb_scrub	  != atomic_read(&volume->cb_scrub) ||
@@ -412,7 +412,7 @@ int afs_validate(struct afs_vnode *vnode, struct key *key)
 	    vnode->cb_scrub	  != cb_scrub ||
 	    volume->cb_expires_at <= deadline ||
 	    atomic_read(&volume->cb_v_check) != atomic_read(&volume->cb_v_break) ||
-	    vnode->cb_expires_at <= deadline
+	    atomic64_read(&vnode->cb_expires_at) <= deadline
 	    ) {
 		ret = afs_fetch_status(vnode, key, false, NULL);
 		if (ret < 0) {
-- 
2.43.0


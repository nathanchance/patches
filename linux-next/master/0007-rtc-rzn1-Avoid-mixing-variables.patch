From 45aecf4b785931d329d14f045a092df168281487 Mon Sep 17 00:00:00 2001
From: Miquel Raynal <miquel.raynal@bootlin.com>
Date: Thu, 19 May 2022 15:23:00 +0200
Subject: [PATCH 07/18] rtc: rzn1: Avoid mixing variables

In the ->set_offset() callback, the 'val' variable is used for two
different purposes at the same time, which is oviously wrong:
- It contains the intermediate value of the SUBU register that must be
  written at the end of ->set_offset().
- It is used in the middle of the above calculations to poll the CTL2
  register for a specific value.

Let's introduce a 'ctl2' variable just for the readl_poll_timeout()
call and use it there in place of 'var'.

In order to avoid mixing those two variables again, let's rename the
remaining occurences of 'val' into 'subu' and initialize it to 0 to
avoid the uninitialized variable situation reported by Tom Rix and Colin
Ian King already.

No real "Fixes:" applies here because the original patch has not yet
reached Linus' tree, but the offending commit is named:
"rtc: rzn1: Add oscillator offset support"

Reported-by: Tom Rix <trix@redhat.com>
Reported-by: Colin Ian King <colin.i.king@gmail.com>
Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
Link: https://lore.kernel.org/r/20220519132300.424095-1-miquel.raynal@bootlin.com
Signed-off-by: Nathan Chancellor <nathan@kernel.org>
---
 drivers/rtc/rtc-rzn1.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/rtc/rtc-rzn1.c b/drivers/rtc/rtc-rzn1.c
index f92d1398b0f1..1108d98af86f 100644
--- a/drivers/rtc/rtc-rzn1.c
+++ b/drivers/rtc/rtc-rzn1.c
@@ -272,7 +272,7 @@ static int rzn1_rtc_set_offset(struct device *dev, long offset)
 	struct rzn1_rtc *rtc = dev_get_drvdata(dev);
 	unsigned int steps;
 	int stepsh, stepsl;
-	u32 val;
+	u32 subu = 0, ctl2;
 	int ret;
 
 	/*
@@ -288,7 +288,7 @@ static int rzn1_rtc_set_offset(struct device *dev, long offset)
 	if (stepsh >= -0x3E && stepsh <= 0x3E) {
 		/* 1017 ppb per step */
 		steps = stepsh;
-		val |= RZN1_RTC_SUBU_DEV;
+		subu |= RZN1_RTC_SUBU_DEV;
 	} else if (stepsl >= -0x3E && stepsl <= 0x3E) {
 		/* 3051 ppb per step */
 		steps = stepsl;
@@ -300,18 +300,18 @@ static int rzn1_rtc_set_offset(struct device *dev, long offset)
 		return 0;
 
 	if (steps > 0) {
-		val |= steps + 1;
+		subu |= steps + 1;
 	} else {
-		val |= RZN1_RTC_SUBU_DECR;
-		val |= (~(-steps - 1)) & 0x3F;
+		subu |= RZN1_RTC_SUBU_DECR;
+		subu |= (~(-steps - 1)) & 0x3F;
 	}
 
-	ret = readl_poll_timeout(rtc->base + RZN1_RTC_CTL2, val,
-				 !(val & RZN1_RTC_CTL2_WUST), 100, 2000000);
+	ret = readl_poll_timeout(rtc->base + RZN1_RTC_CTL2, ctl2,
+				 !(ctl2 & RZN1_RTC_CTL2_WUST), 100, 2000000);
 	if (ret)
 		return ret;
 
-	writel(val, rtc->base + RZN1_RTC_SUBU);
+	writel(subu, rtc->base + RZN1_RTC_SUBU);
 
 	return 0;
 }
-- 
2.36.1


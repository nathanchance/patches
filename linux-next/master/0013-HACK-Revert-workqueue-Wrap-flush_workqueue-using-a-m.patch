From 1955047050e0cedf5ff7d42fe9feea80a06c9fc9 Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <nathan@kernel.org>
Date: Mon, 23 May 2022 12:16:27 -0700
Subject: [PATCH 13/18] HACK: Revert "workqueue: Wrap flush_workqueue() using a
 macro"

This reverts commit 84baad17cb8286b6b53b675f8c3d7343ee6a990c.

This is unacceptable. Fix the warnings first then enable the warning.

Signed-off-by: Nathan Chancellor <nathan@kernel.org>
---
 include/linux/workqueue.h | 48 +++------------------------------------
 kernel/workqueue.c        |  9 --------
 2 files changed, 3 insertions(+), 54 deletions(-)

diff --git a/include/linux/workqueue.h b/include/linux/workqueue.h
index 19c3861e4353..7fee9b6cfede 100644
--- a/include/linux/workqueue.h
+++ b/include/linux/workqueue.h
@@ -569,8 +569,9 @@ static inline bool schedule_work(struct work_struct *work)
  * Forces execution of the kernel-global workqueue and blocks until its
  * completion.
  *
- * It's very easy to get into trouble if you don't take great care.
- * Either of the following situations will lead to deadlock:
+ * Think twice before calling this function!  It's very easy to get into
+ * trouble if you don't take great care.  Either of the following situations
+ * will lead to deadlock:
  *
  *	One of the work items currently on the workqueue needs to acquire
  *	a lock held by your code or its caller.
@@ -585,10 +586,6 @@ static inline bool schedule_work(struct work_struct *work)
  * need to know that a particular work item isn't queued and isn't running.
  * In such cases you should use cancel_delayed_work_sync() or
  * cancel_work_sync() instead.
- *
- * Please stop calling this function! A conversion to stop flushing system-wide
- * workqueues is in progress. This function will be removed after all in-tree
- * users stopped calling this function.
  */
 static inline void flush_scheduled_work(void)
 {
@@ -666,43 +663,4 @@ int workqueue_offline_cpu(unsigned int cpu);
 void __init workqueue_init_early(void);
 void __init workqueue_init(void);
 
-/*
- * Detect attempt to flush system-wide workqueues at compile time when possible.
- *
- * See https://lkml.kernel.org/r/49925af7-78a8-a3dd-bce6-cfc02e1a9236@I-love.SAKURA.ne.jp
- * for reasons and steps for converting system-wide workqueues into local workqueues.
- */
-extern void __warn_flushing_systemwide_wq(void)
-	__compiletime_warning("Please avoid flushing system-wide workqueues.");
-
-/* Always warn, for there is no in-tree flush_workqueue(system_*_wq) user. */
-#define flush_workqueue(wq)						\
-do {									\
-	if ((__builtin_constant_p(&(wq) == &system_wq) &&		\
-	     &(wq) == &system_wq) ||					\
-	    (__builtin_constant_p(&(wq) == &system_highpri_wq) &&	\
-	     &(wq) == &system_highpri_wq) ||				\
-	    (__builtin_constant_p(&(wq) == &system_long_wq) &&		\
-	     &(wq) == &system_long_wq) ||				\
-	    (__builtin_constant_p(&(wq) == &system_unbound_wq) &&	\
-	     &(wq) == &system_unbound_wq) ||				\
-	    (__builtin_constant_p(&(wq) == &system_freezable_wq) &&	\
-	     &(wq) == &system_freezable_wq) ||				\
-	    (__builtin_constant_p(&(wq) == &system_power_efficient_wq) && \
-	     &(wq) == &system_power_efficient_wq) ||			\
-	    (__builtin_constant_p(&(wq) == &system_freezable_power_efficient_wq) && \
-	     &(wq) == &system_freezable_power_efficient_wq))		\
-		__warn_flushing_systemwide_wq();			\
-	flush_workqueue(wq);						\
-} while (0)
-
-/*
- * Warn only if emitting warning message does not cause build failure and
- * the developer wants warning about possibility of deadlock, for there are
- * currently in-tree flush_scheduled_work() users.
- */
-#if !defined(CONFIG_WERROR) && defined(CONFIG_PROVE_LOCKING)
-#define flush_scheduled_work() flush_workqueue(system_wq)
-#endif
-
 #endif
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 68e4e0db7d82..4056f2a3f9d5 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -2794,7 +2794,6 @@ static bool flush_workqueue_prep_pwqs(struct workqueue_struct *wq,
  * This function sleeps until all work items which were queued on entry
  * have finished execution, but it is not livelocked by new incoming ones.
  */
-#undef flush_workqueue
 void flush_workqueue(struct workqueue_struct *wq)
 {
 	struct wq_flusher this_flusher = {
@@ -6112,11 +6111,3 @@ void __init workqueue_init(void)
 	wq_online = true;
 	wq_watchdog_init();
 }
-
-/*
- * Despite the naming, this is a no-op function which is here only for avoiding
- * link error. Since compile-time warning may fail to catch, we will need to
- * emit run-time warning from flush_workqueue().
- */
-void __warn_flushing_systemwide_wq(void) { }
-EXPORT_SYMBOL(__warn_flushing_systemwide_wq);
-- 
2.36.1

